module Ticker (tick, tock, tasks) where
{-| This module offers on-demand ticks, as an alternative to using `Time.fps`
or `Time.fpsWhen` to manage a Signal that produces ticks, or using `Task.sleep`
to delay a task.

* The ticks generated by this module will fire according to the browser's
  native requestAnimationFrame() method -- that is, they will fire when the
  browser needs a new frame.

* Multiple requests for a tick will be consolidated until the tick fires,
  so that requestAnimationFrame() is only called once per tick. When the tick
  fires, all the conslidated requests will be fulfilled.

* Once your tick fires, if you need another one (e.g. your animation is not
  finished), then you need to request another one -- they don't continue to
  flow automatically.

Note that this module provides a signal of tasks which need to be executed. In
order for that to happen, you will need to connect that signal to a port in
your main module. For instance:

    import Ticker

    ...

    port tickerTasks : Signal (Task () ())
    port tickerTasks =
        Ticker.tasks

Also note that the tasks returned by `tick` and `tock` are *not* automatically
sent through this Signal -- you will need to arrange for those tasks to be
executed in same way that other tasks are executed in your app.

@docs tick, tock, tasks

-}

import Task exposing (Task)
import Time exposing (Time)
import Signal exposing (Address, Mailbox, send, mailbox, foldp)
import Native.Tick


{- Public API -}

{-| Returns a task which, when excecuted, waits for the browser to request an
animation frame (via the browser's native requestAnimationFrame() method). It
then calls the function you provided, passing along the Time provided by 
requestAnimationFrame(). The Task returned by your function is then immediately
executed.
-}
tick : (Time -> Task x a) -> Task () ()
tick func =
    send actions.address <|
        Request (converge func)


{-| Like tick, except that you provide a function which returns an action, which
will be sent to the address you provide, when the next frame is needed. Typically,
the 'function' you provide will be an action tag, for an action like:

    type Action =
        Tick Time |
        ... other actions

Then, assuming you have an `address` which accepts such actions, you could call:

    tock address Tick

... which will return a Task that, when executed, will wait until an animation
frame is needed and then send the message to the address.
-}
tock : Address action -> (Time -> action) -> Task () ()
tock address func =
    tick <|
        send address << func


-- Note that there's really no way to avoid forcing the user of the library to
-- connect the signal to a port ... it's a consequence of Elm's rule that only
-- the main module can create ports.

{-| A signal of tasks which the module needs to be executed in order to maintain
its internal state. In order to use this module, you need to connect this
signal to a port in your main module -- see example above.
-}
tasks : Signal (Task () ())
tasks =
    Signal.filterMap snd (Task.succeed ()) steps


{- Implementation -}

{- The signature for `tick` calls for a function that produces a `Task x a` 
because we don't actually care what the task does. However, internally we need
to put the functions in a list. To put them in the same list, the x's and a's
would need to converge -- that is, you can't have a List of Tasks unless you
converge the x's and a's. So, we have to force them to converge. At least, I
think this is the explanation for the type errors I was getting when I tried
the `Task x a` approach without forcing convergence.
-}

converge : (Time -> Task x a) -> (Time -> Task () ()) 
converge func =
    Task.map (always ()) <<
        Task.mapError (always ()) <<
            func


-- Make types less verbose
type alias HandledTask = Task () ()
type alias Func = (Time -> HandledTask)


type Action
    = Request Func
    | Execute Time


actions : Mailbox Action
actions =
    mailbox (Execute 0)


steps : Signal (List Func, Maybe HandledTask)
steps =
    foldp step ([], Nothing) actions.signal


step : Action -> (List Func, Maybe HandledTask) -> (List Func, Maybe HandledTask)
step action (list, task) =
    case action of
        Request func ->
            if List.isEmpty list
                then ([func], Just schedule)
                else (func :: list, Nothing)

        Execute time ->
            (
                [],
                Just <|
                    batch <|
                        List.map ((|>) time) list
            )


batch : List (Task x a) -> HandledTask
batch tasks =
    Task.map (always ()) <|
        Task.sequence <|
            List.map Task.spawn tasks


schedule : HandledTask
schedule =
    requestAnimationFrame <|
        Signal.send actions.address << Execute


requestAnimationFrame : (Time -> HandledTask) -> HandledTask
requestAnimationFrame =
    Native.Tick.requestAnimationFrame

